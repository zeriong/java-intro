package extends1.overriding;

public class ElectricCar extends Car {

    // 아래 @로 시작하는 것을 애노테이션(어노테이션) 이라고 한다.
    // 애노테이션은 주석과 같은 느낌이지만 프로그램이 읽을 수 있다
    //
    // 주석과 같은 영역이라 정확하게 부모에서 사용되는 매서드와 같다면
    // 굳이 Override 애노테이션을 적지 않아도 정상 작동하지만
    // 실수를 방지하기 위해서 Override 애노테이션을 활용한다.
    // 위 설명과 같이 프로그램(컴파일러)가 읽을 수 있는 주석이기 때문에
    // Override 애노테이션을 위에 작성하고 실제로 상속된 부모에 존재하지
    // 않는 매서드명을 사용하면 컴파일 에러를 발생시켜준다.
    //
    // 즉, 실수 방지차원에서 Override를 활용하는 것이 좋다.
    //
    // 오버라이드는 상속된 부모에 이미 존재하는 매서드명을 유지하면서
    // 새로운 기능을 재정의할 때 활용할 수 있다.
    //
    // 오버라이드의 주요 조건
    // 1. 매서드의 이름이 상속된 부모의 매서드와 같아야 함
    // 2. 매개변수 타입, 순서, 개수가 같아야함
    // 3. 반환 타입이 같아야 함
    // 4. 접근 제어자는 상위 클래스의 매서드보다 더 제한적일 수 없음
    // 5. 상위 클래스의 매서드보다 더 많은 예외를 throws로 선언 불가하여 더 적거나 같은 수의 예외나
    //    하위 타입의 예외는 선언할 수 있다.
    // 6. static, final, private 키워드가 붙은 매서드는 오버라이딩할 수 없다.
    // 7. 생성자는 오버라이딩할 수 없다.
    @Override
    public void move() {
        System.out.println("전기차를 빨리 이동");
    }

    public void charge() {
        System.out.println("차를 충전");
    }
}
